---
import BaseLayout from '../../../../layouts/BaseLayout.astro';
import { fetchArticles, fetchArticleBySlug, pickLang } from '../../../../lib/sanity';
import { mockArticles } from '../../../../lib/data';
import { toHTML } from '@portabletext/to-html';

export const prerender = true;

export async function getStaticPaths() {
  const sanity = await fetchArticles();
  const articles = sanity || mockArticles;
  return articles
    .filter((a: any) => a?.slug)
    .map((a: any) => ({ params: { slug: a.slug } }));
}

const { slug } = Astro.params as { slug: string };

let article = mockArticles.find((a) => a.slug === slug);
const sanityArticle = await fetchArticleBySlug(slug);
if (sanityArticle) article = sanityArticle;

const lang: 'so' = 'so';

function bodyToHtml(bodyObj: any) {
  const blocks = bodyObj?.[lang] ?? bodyObj?.en ?? bodyObj?.so ?? [];
  try {
    let html = toHTML(blocks);

    // Post-process: Split paragraphs containing multiple numbered clauses
    html = html.replace(/<p>(.*?)<\/p>/gs, (match, content) => {
      // Check if paragraph contains numbered clauses like (1), (2), (3)
      if (/\(\d+\)/.test(content)) {
        // Split by numbered clauses
        const clauses = content.split(/(?=\(\d+\))/).filter((c: string) => c.trim());

        if (clauses.length > 1) {
          // Multiple clauses - create separate paragraphs
          return clauses.map((clause: string) => {
            const trimmed = clause.trim();
            // Sub-clauses with letters
            if (/^\([A-Za-z]\)/.test(trimmed)) {
              return `<p class="ml-8 mb-2 text-base leading-relaxed">${trimmed}</p>`;
            }
            // Sub-clauses with roman numerals
            if (/^\([ivxlcdm]+\)/i.test(trimmed)) {
              return `<p class="ml-16 mb-2 text-base leading-relaxed">${trimmed}</p>`;
            }
            // Main numbered clauses
            return `<p class="mb-3 text-base leading-relaxed">${trimmed}</p>`;
          }).join('');
        }
      }

      // Single clause or regular paragraph - add styling
      if (/^\([A-Za-z]\)/.test(content)) {
        return `<p class="ml-8 mb-2 text-base leading-relaxed">${content}</p>`;
      }
      if (/^\([ivxlcdm]+\)/i.test(content)) {
        return `<p class="ml-16 mb-2 text-base leading-relaxed">${content}</p>`;
      }
      return `<p class="mb-3 text-base leading-relaxed">${content}</p>`;
    });

    return html;
  } catch { return ''; }
}

function safeTitle(obj: any) { return pickLang(obj, lang); }

---

<BaseLayout lang={lang} title={article ? safeTitle(article.title) : 'Article'} description={article ? safeTitle(article.title) : ''}>
  <section class="py-14">
    <div class="mx-auto max-w-4xl px-4">
      <a href={`/${lang}`} class="text-sm font-semibold text-sky-700">‚Üê Ku noqo</a>

      <div class="mt-6">
        <p class="text-xs font-semibold text-zinc-500">{lang === 'en' ? 'Article' : 'Qodob'} {article?.number}</p>
        <h1 class="mt-2 text-3xl font-extrabold tracking-tight sm:text-4xl">{article ? safeTitle(article.title) : 'Article not found'}</h1>
        <div class="prose-const mt-6 text-zinc-700 dark:text-zinc-200" id="article-body" set:html={article ? bodyToHtml(article.body) : ''} />
      </div>
    </div>
  </section>

  <script>
    // Client-side clause splitting
    const articleBody = document.getElementById('article-body');
    if (articleBody) {
      const paragraphs = articleBody.querySelectorAll('p');
      paragraphs.forEach(p => {
        const text = p.innerHTML;

        // First split by numbered clauses (1), (2), (3)
        if (/\(\d+\)/.test(text)) {
          const clauses = text.split(/(?=\(\d+\))/).filter(c => c.trim());
          if (clauses.length > 1) {
            const wrapper = document.createElement('div');
            clauses.forEach(clause => {
              // Check if this clause contains lettered sub-clauses
              if (/\([A-Za-z]\)/.test(clause)) {
                const subClauses = clause.split(/(?=\([A-Za-z]\))/).filter(sc => sc.trim());
                subClauses.forEach((subClause, idx) => {
                  const newP = document.createElement('p');
                  newP.innerHTML = subClause.trim();
                  // First part (numbered clause) - no indent
                  if (idx === 0) {
                    newP.className = 'mb-3 text-base leading-relaxed';
                  }
                  // Lettered sub-clauses - indent
                  else if (/^\([A-Za-z]\)/.test(subClause.trim())) {
                    newP.className = 'ml-8 mb-2 text-base leading-relaxed';
                  }
                  wrapper.appendChild(newP);
                });
              } else {
                const newP = document.createElement('p');
                newP.innerHTML = clause.trim();
                newP.className = 'mb-3 text-base leading-relaxed';
                wrapper.appendChild(newP);
              }
            });
            p.replaceWith(...wrapper.children);
          }
        }
        // Handle standalone lettered clauses (not part of numbered clauses)
        else if (/\([A-Za-z]\)/.test(text)) {
          const clauses = text.split(/(?=\([A-Za-z]\))/).filter(c => c.trim());
          if (clauses.length > 1) {
            const wrapper = document.createElement('div');
            clauses.forEach(clause => {
              const newP = document.createElement('p');
              newP.innerHTML = clause.trim();
              newP.className = 'ml-8 mb-2 text-base leading-relaxed';
              wrapper.appendChild(newP);
            });
            p.replaceWith(...wrapper.children);
          }
        }
      });
    }
  </script>
